<!doctype html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js Heightmap · Chunked LOD</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #0c0f17;
      color: #e5e7eb;
    }

    #info {
      position: relative;
      top: 12px;
      left: 12px;
      padding: 10px 14px;
      background: rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.08);
      font: 14px/1.4 Arial, sans-serif;
      border-radius: 8px;
      max-width: 320px;
    }

    #hud {
      position: relative;
      top: 24px;
      left: 12px;
      padding: 10px 14px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.08);
      font: 12px/1.4 monospace;
      border-radius: 8px;
      min-width: 220px;
      color: #cbd5e1;
    }

    #home-btn {
      position: absolute;
      top: 20px;
      right: 12px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 8px;
      color: #e5e7eb;
      font: 13px/1.2 Arial, sans-serif;
      text-decoration: none;
      backdrop-filter: blur(6px);
      z-index: 6;
    }

    #home-btn:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    a {
      color: #7dd3fc;
      text-decoration: none;
    }

    div.dashboardsContainer {
      width: 400px;
      position: absolute;
      top: 0;
      left: 0;
    }

    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 18px;
      height: 18px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 7;
    }

    #crosshair::before,
    #crosshair::after {
      content: "";
      position: absolute;
      background: rgba(255, 255, 255, 0.85);
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }

    #crosshair::before {
      width: 14px;
      height: 2px;
    }

    #crosshair::after {
      width: 2px;
      height: 14px;
    }
  </style>
</head>

<body>

  <div class="dashboardsContainer">

    <div id="info">
      Mapa infinito com SEED fixa (Simplex fBM), dividido em chunks com LOD para depuração.<br />
      Clique no canvas para capturar o mouse · WASD move | Espaço salta · Scroll gira quando solto.
    </div>

    <div id="hud">
      <div>Chunks carregados: --</div>
      <div>LOD levels: --</div>
      <div>Tris: --</div>
      <div>FPS: --</div>
    </div>

  </div>

  <canvas id="c"></canvas>
  <a id="home-btn" href="/index.html">Voltar ao início</a>
  <div id="crosshair"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
    import Stats from 'three/examples/jsm/libs/stats.module.js';
    import { createNoise2D } from 'simplex-noise';
    import alea from 'alea';
    import { createZombie } from './zombie.js';

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0c0f17);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.set(20, 20, 20);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 12, 0);

    const fpControls = new PointerLockControls(camera, renderer.domElement);
    camera.position.set(0, 12, 20);
    // scene.add(fpControls.getObject());

    scene.add(new THREE.HemisphereLight(0xa0b9ff, 0x101820, 0.75));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(300, 500, 200);
    scene.add(dirLight);

    const CHUNK_SIZE = 25;
    const LOD_LEVELS = [
      { segments: 32, distance: CHUNK_SIZE * 0.75 },
      { segments: 16, distance: CHUNK_SIZE * 1.5 },
      { segments: 8, distance: CHUNK_SIZE * 3 },
      { segments: 4, distance: CHUNK_SIZE * 5 },
    ];
    const HEIGHT_SCALE = 40;
    const CHUNK_RADIUS = 2; // chunks carregados ao redor da câmera
    const EYE_HEIGHT = 5;

    const hudEl = document.getElementById('hud');
    const stats = new Stats();
    stats.showPanel(0);
    stats.dom.style.position = 'absolute';
    stats.dom.style.top = '12px';
    stats.dom.style.left = 'calc(50% - 40px)';
    document.body.appendChild(stats.dom);

    const noise2D = createNoise2D(alea('heightmap-seed-03'));
    const chunkCache = new Map();
    const materialCache = new Map();
    const clock = new THREE.Clock();
    const gpuInfo = getGPUInfo(renderer.getContext());
    const cpuInfo = navigator.hardwareConcurrency || 'n/d';
    const npcs = [];

    function sampleHeight(x, z) {
      const nx = x / 180;
      const nz = z / 180;
      const e =
        1.0 * noise2D(nx, nz) +
        0.6 * noise2D(nx * 2.2, nz * 2.2) +
        0.35 * noise2D(nx * 4.4, nz * 4.4) +
        0.18 * noise2D(nx * 7.5, nz * 7.5);
      return ((e + 1) / 2) * HEIGHT_SCALE;
    }

    function gradientColor(h) {
      const t = Math.max(0, Math.min(1, h / HEIGHT_SCALE));
      if (t < 0.35) return lerp([0x1c, 0x4a, 0x7a], [0x2f, 0x8d, 0xff], t / 0.35);
      if (t < 0.55) return lerp([0x2d, 0x6a, 0x3f], [0x54, 0xa8, 0x63], (t - 0.35) / 0.2);
      if (t < 0.8) return lerp([0x73, 0x68, 0x57], [0xb1, 0xa3, 0x83], (t - 0.55) / 0.25);
      return lerp([0xe8, 0xeb, 0xf0], [0xff, 0xff, 0xff], (t - 0.8) / 0.2);
    }

    function lerp(c1, c2, t) {
      const k = Math.max(0, Math.min(1, t));
      return {
        r: (c1[0] + (c2[0] - c1[0]) * k) / 255,
        g: (c1[1] + (c2[1] - c1[1]) * k) / 255,
        b: (c1[2] + (c2[2] - c1[2]) * k) / 255,
      };
    }

    function chunkKey(ix, iz) {
      return `${ix},${iz}`;
    }

    function createMaterial(key) {
      if (materialCache.has(key)) return materialCache.get(key);
      const mat = new THREE.MeshStandardMaterial({
        vertexColors: true,
        flatShading: false,
        roughness: 0.85,
        metalness: 0.0,
      });
      materialCache.set(key, mat);
      return mat;
    }

    function makeGeometry(segments, centerX, centerZ) {
      const geom = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, segments, segments);
      geom.rotateX(-Math.PI / 2);
      const pos = geom.attributes.position;
      const colors = new Float32Array(pos.count * 3);
      for (let i = 0; i < pos.count; i++) {
        const vx = pos.getX(i) + centerX;
        const vz = pos.getZ(i) + centerZ;
        const h = sampleHeight(vx, vz);
        pos.setY(i, h);
        const c = gradientColor(h);
        colors[i * 3 + 0] = c.r;
        colors[i * 3 + 1] = c.g;
        colors[i * 3 + 2] = c.b;
      }
      geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geom.computeVertexNormals();
      return geom;
    }

    function buildChunk(ix, iz) {
      const key = chunkKey(ix, iz);
      if (chunkCache.has(key)) return chunkCache.get(key);

      const centerX = ix * CHUNK_SIZE + CHUNK_SIZE / 2;
      const centerZ = iz * CHUNK_SIZE + CHUNK_SIZE / 2;
      const lod = new THREE.LOD();

      for (const level of LOD_LEVELS) {
        const geometry = makeGeometry(level.segments, centerX, centerZ);
        const mesh = new THREE.Mesh(geometry, createMaterial('terrain'));
        mesh.position.set(centerX, 0, centerZ);
        lod.addLevel(mesh, level.distance);
      }

      scene.add(lod);
      const chunk = { lod, ix, iz, lastUsed: performance.now() };
      chunkCache.set(key, chunk);
      return chunk;
    }

    function disposeChunk(chunk) {
      if (!chunk || !chunk.lod) return;
      chunk.lod.levels.forEach(({ object }) => {
        if (object.geometry) object.geometry.dispose();
      });
      scene.remove(chunk.lod);
    }

    function updateChunks() {
      const ix = Math.floor(camera.position.x / CHUNK_SIZE);
      const iz = Math.floor(camera.position.z / CHUNK_SIZE);

      const needed = new Set();
      for (let dz = -CHUNK_RADIUS; dz <= CHUNK_RADIUS; dz++) {
        for (let dx = -CHUNK_RADIUS; dx <= CHUNK_RADIUS; dx++) {
          const nx = ix + dx;
          const nz = iz + dz;
          needed.add(chunkKey(nx, nz));
          buildChunk(nx, nz).lastUsed = performance.now();
        }
      }

      for (const [key, chunk] of chunkCache.entries()) {
        if (!needed.has(key)) {
          disposeChunk(chunk);
          chunkCache.delete(key);
        }
      }
    }

    function updateHud() {
      const info = renderer.info;
      const tris = info.render.triangles;
      const fps = Math.round(stats.getFPS ? stats.getFPS() : 0) || '--';
      const mem = performance.memory
        ? `${(performance.memory.usedJSHeapSize / 1048576).toFixed(1)} / ${(performance.memory.jsHeapSizeLimit / 1048576).toFixed(0)} MB`
        : 'n/d';
      hudEl.innerHTML = `
        <div>Chunks carregados: ${chunkCache.size}</div>
        <div>LOD levels: ${LOD_LEVELS.length}</div>
        <div>Draws: ${info.render.calls} | Tris: ${tris.toLocaleString('pt-BR')}</div>
        <div>Geom/Tex: ${info.memory.geometries} / ${info.memory.textures}</div>
        <div>GPU: ${gpuInfo}</div>
        <div>CPU cores: ${cpuInfo}</div>
        <div>Heap: ${mem}</div>
        <div>Altura do pulo: ${heightAboveGround.toFixed(2)} m</div>
        <div>Altura máx. registrada: ${maxJumpHeight.toFixed(2)} m</div>
        <div>FPS: ${fps}</div>
      `;
    }

    const keyState = { forward: false, backward: false, left: false, right: false, jump: false };
    let isOnGround = false;
    let verticalVel = 0;
    let heightAboveGround = 0;
    let maxJumpHeight = 0;
    const MAX_JUMP_HEIGHT = 10; // metros acima do solo
    const npcTarget = new THREE.Vector3();

    function setupPointerLock() {
      const infoEl = document.getElementById('info');
      const target = renderer.domElement;
      target.addEventListener('click', (e) => {
        e.preventDefault();
        fpControls.lock();
      });
      fpControls.addEventListener('lock', () => {
        infoEl.style.opacity = '0.75';
        controls.enabled = false;
      });
      fpControls.addEventListener('unlock', () => {
        infoEl.style.opacity = '1';
        controls.enabled = true;
        controls.target.copy(camera.position);
        controls.update();
      });
    }

    function setupKeys() {
      const handler = (pressed) => (event) => {
        switch (event.code) {
          case 'KeyW':
          case 'ArrowUp':
            keyState.forward = pressed;
            break;
          case 'KeyS':
          case 'ArrowDown':
            keyState.backward = pressed;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            keyState.left = pressed;
            break;
          case 'KeyD':
          case 'ArrowRight':
            keyState.right = pressed;
            break;
          case 'Space':
            keyState.jump = pressed;
            break;
        }
      };
      document.addEventListener('keydown', handler(true));
      document.addEventListener('keyup', handler(false));
    }

    const tmpDir = new THREE.Vector3();
    const forward = new THREE.Vector3();
    const right = new THREE.Vector3();

    function updateMovement(delta) {
      if (!fpControls.isLocked) return;

      const dirX = (keyState.right ? 1 : 0) - (keyState.left ? 1 : 0);
      const dirZ = (keyState.forward ? 1 : 0) - (keyState.backward ? 1 : 0);
      const hasInput = dirX !== 0 || dirZ !== 0;
      const speed = 18;

      if (hasInput) {
        forward.copy(fpControls.getDirection(tmpDir)).setY(0).normalize();
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
        const pos = camera.position;
        pos.addScaledVector(forward, dirZ * speed * delta);
        pos.addScaledVector(right, dirX * speed * delta);
      }

      // Gravity / jump (Matching example01 physics)
      const gravity = 35;
      const jumpSpeed = 18;

      verticalVel -= gravity * delta;

      const pos = camera.position;
      const ground = sampleHeight(pos.x, pos.z);
      const minY = ground + EYE_HEIGHT;

      if (keyState.jump && isOnGround) {
        verticalVel = jumpSpeed;
        isOnGround = false;
      }

      // Apply velocity
      if (pos.y + verticalVel * delta <= minY) {
        pos.y = minY;
        verticalVel = 0;
        isOnGround = true;
      } else {
        pos.y += verticalVel * delta;
        isOnGround = false;
      }

      heightAboveGround = Math.max(0, pos.y - minY);
      if (heightAboveGround > maxJumpHeight) {
        maxJumpHeight = heightAboveGround;
      }
    }

    function updateNPCs(delta, time) {
      if (npcs.length === 0) return;
      const playerPos = camera.position;
      npcs.forEach((npc) => {
        npc.update(delta, time);
        // Aproxima lentamente do player.
        npcTarget.copy(playerPos);
        const pos = npc.object.position;
        const dir = npcTarget.clone().sub(pos);
        dir.y = 0;
        const dist = dir.length();
        const stopDistance = 1.5; // mantém ~1.5m da mira/jogador
        if (dist > stopDistance) {
          dir.normalize();
          const speed = 7.5;
          pos.addScaledVector(dir, speed * delta);
          // Orienta o zumbi para a direção de perseguição.
          npc.object.rotation.y = Math.atan2(dir.x, dir.z);
        }
        pos.y = sampleHeight(pos.x, pos.z) + 0.1;
      });
    }

    function animate() {
      const delta = clock.getDelta();
      stats.begin();
      requestAnimationFrame(animate);
      updateMovement(delta);
      updateNPCs(delta, performance.now() * 0.001);
      updateChunks();
      if (!fpControls.isLocked) {
        controls.update();
      }
      renderer.render(scene, camera);
      stats.end();
      updateHud();
    }

    function onResize() {
      const { innerWidth: w, innerHeight: h } = window;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }

    window.addEventListener('resize', onResize);

    // Inicializa alguns chunks ao redor da origem
    updateChunks();
    setupPointerLock();
    setupKeys();
    spawnNPCs();
    animate();

    function spawnNPCs() {
      const spawnPos = new THREE.Vector3(10, 0, 10);
      const npc = createZombie({ scale: 1.05, speedFactor: 2.5 });
      npc.object.position.copy(spawnPos);
      npc.object.position.y = sampleHeight(spawnPos.x, spawnPos.z) + 0.1;
      scene.add(npc.object);
      npcs.push(npc);
    }

    function getGPUInfo(gl) {
      const ext = gl.getExtension('WEBGL_debug_renderer_info');
      if (ext) {
        const vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
        const rendererName = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
        return `${vendor} | ${rendererName}`;
      }
      return 'n/d';
    }
  </script>
  <div
    style="position: fixed; bottom: 10px; right: 10px; color: rgba(255,255,255,0.3); font-size: 11px; font-family: sans-serif; pointer-events: none;">
    Exemplos criados com o auxílio de IA: Antigravity + Models and VSCode CODEX extension.
  </div>
</body>

</html>