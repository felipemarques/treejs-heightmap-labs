<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js Heightmap Demo</title>
  <style>
    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0b1320;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #e8ecf5;
    }

    #info {
      position: fixed;
      top: 12px;
      left: 12px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 8px;
      font-size: 13px;
      letter-spacing: 0.1px;
      backdrop-filter: blur(6px);
      z-index: 5;
    }

    #info strong {
      color: #89c2ff;
    }

    #home-btn {
      position: fixed;
      top: 76px;
      right: 12px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 8px;
      color: #e8ecf5;
      font-size: 13px;
      text-decoration: none;
      backdrop-filter: blur(6px);
      z-index: 6;
    }

    #home-btn:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <a id="home-btn" href="/index.html">Voltar ao início</a>
  <div id="info">
    <strong>Heightmap:</strong> heightmaps/sample-heightmap.png<br />
    Seed 1337 · Noise: Simplex (fBm)<br />
    Clique no canvas para capturar o mouse · WASD move · Esc solta · Scroll gira quando solto
  </div>
  <canvas id="scene-canvas"></canvas>

  <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

    const canvas = document.getElementById("scene-canvas");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050710);
    scene.fog = new THREE.Fog(0x050710, 180, 320);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(130, 90, 130);

    // FPS navigation (Pointer Lock)
    const fpControls = new PointerLockControls(camera, renderer.domElement);
    camera.position.set(0, 25, 80);
    scene.add(fpControls.getObject());

    // Orbit para inspeção quando mouse não está capturado
    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.enableDamping = true;
    orbit.enabled = true;

    const hemiLight = new THREE.HemisphereLight(0xa7c7ff, 0x0a0f1a, 0.8);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
    dirLight.position.set(80, 120, 60);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    scene.add(dirLight);

    const HEIGHTMAP_SRC = "/examples/example01/heightmaps/sample-heightmap.png";

    async function loadHeightData(src) {
      const img = await new Promise((resolve, reject) => {
        const image = new Image();
        image.src = src;
        image.crossOrigin = "anonymous";
        image.onload = () => resolve(image);
        image.onerror = reject;
      });

      const canvasHM = document.createElement("canvas");
      canvasHM.width = img.width;
      canvasHM.height = img.height;
      const ctx = canvasHM.getContext("2d");
      ctx.drawImage(img, 0, 0);
      const { data } = ctx.getImageData(0, 0, img.width, img.height);
      const heights = new Float32Array(img.width * img.height);
      for (let i = 0; i < heights.length; i++) {
        heights[i] = data[i * 4] / 255; // grayscale in R channel
      }
      return { widths: img.width, heightsCount: img.height, data: heights };
    }

    function heightAt(data, w, h, x, z, size, scale, bias = 0) {
      // x,z in world coordinates centered at 0
      const half = size / 2;
      const u = THREE.MathUtils.clamp((x + half) / size, 0, 1);
      const v = THREE.MathUtils.clamp((z + half) / size, 0, 1);
      const px = u * (w - 1);
      const pz = v * (h - 1);
      const x0 = Math.floor(px);
      const z0 = Math.floor(pz);
      const x1 = Math.min(x0 + 1, w - 1);
      const z1 = Math.min(z0 + 1, h - 1);
      const xf = px - x0;
      const zf = pz - z0;
      const i = z0 * w + x0;
      const i2 = z0 * w + x1;
      const i3 = z1 * w + x0;
      const i4 = z1 * w + x1;
      const a = THREE.MathUtils.lerp(data[i], data[i2], xf);
      const b = THREE.MathUtils.lerp(data[i3], data[i4], xf);
      return THREE.MathUtils.lerp(a, b, zf) * scale + bias;
    }

    async function buildTerrain() {
      const { widths: hmW, heightsCount: hmH, data: heights } = await loadHeightData(HEIGHTMAP_SRC);
      // Terrain sizing controls
      const size = 260; // world size of the square terrain
      const heightScale = 42; // max elevation offset
      const heightBias = -6; // lowers the whole terrain
      const geometry = new THREE.PlaneGeometry(size, size, hmW - 1, hmH - 1);
      geometry.rotateX(-Math.PI / 2);

      const position = geometry.attributes.position;
      for (let i = 0; i < position.count; i++) {
        const ix = i % hmW;
        const iz = Math.floor(i / hmW);
        const h = heights[iz * hmW + ix] * heightScale + heightBias; // slight bias down
        position.setY(i, h);
      }
      position.needsUpdate = true;
      geometry.computeVertexNormals();

      const texture = new THREE.TextureLoader().load(HEIGHTMAP_SRC);
      texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;

      const material = new THREE.MeshStandardMaterial({
        color: 0x8aa1b8,
        map: texture,
        metalness: 0.15,
        roughness: 0.85,
      });

      const terrain = new THREE.Mesh(geometry, material);
      terrain.receiveShadow = true;
      terrain.castShadow = true;
      scene.add(terrain);

      return { terrain, heights, hmW, hmH, size, heightScale, heightBias };
    }

    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(460, 80).rotateX(-Math.PI / 2),
      new THREE.MeshStandardMaterial({ color: 0x050710, roughness: 1.0 })
    );
    ground.receiveShadow = true;
    scene.add(ground);

    // Simple starfield
    function addStars() {
      const starCount = 1500;
      const radius = 800;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        const phi = Math.acos(2 * Math.random() - 1);
        const theta = 2 * Math.PI * Math.random();
        const r = radius;
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.cos(phi);
        const z = r * Math.sin(phi) * Math.sin(theta);
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
      }
      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({ color: 0xffffff, size: 1.6, sizeAttenuation: true, transparent: true, opacity: 0.9 });
      const stars = new THREE.Points(geometry, material);
      scene.add(stars);
    }
    addStars();

    function setupPointerLock() {
      const blocker = document.getElementById("info");
      const clickTarget = renderer.domElement;
      const onClick = (event) => {
        event.preventDefault();
        fpControls.lock();
      };
      clickTarget.addEventListener("click", onClick);
      fpControls.addEventListener("lock", () => {
        blocker.style.opacity = "0.7";
        orbit.enabled = false;
      });
      fpControls.addEventListener("unlock", () => {
        blocker.style.opacity = "1";
        orbit.enabled = true;
        orbit.target.copy(fpControls.getObject().position);
        orbit.update();
      });
    }

    const keyState = { forward: false, backward: false, left: false, right: false };
    function setupKeys() {
      const onKey = (state) => (event) => {
        switch (event.code) {
          case "KeyW":
          case "ArrowUp":
            keyState.forward = state;
            break;
          case "KeyS":
          case "ArrowDown":
            keyState.backward = state;
            break;
          case "KeyA":
          case "ArrowLeft":
            keyState.left = state;
            break;
          case "KeyD":
          case "ArrowRight":
            keyState.right = state;
            break;
          case "Space":
            if (state && isOnGround) {
              velocity.y = params.jumpSpeed;
              isOnGround = false;
            }
            break;
        }
      };
      document.addEventListener("keydown", onKey(true));
      document.addEventListener("keyup", onKey(false));
    }

    function onResize() {
      const { innerWidth, innerHeight } = window;
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }
    window.addEventListener("resize", onResize);

    const clock = new THREE.Clock();
    const velocity = new THREE.Vector3(); // only Y is used for gravity/jump
    const direction = new THREE.Vector3();
    const forward = new THREE.Vector3();
    const right = new THREE.Vector3();
    const tmpDir = new THREE.Vector3();
    let heightSampler = null;
    let isOnGround = false;

    const params = {
      moveSpeed: 40,
      jumpSpeed: 18,
      gravity: 35,
    };

    buildTerrain().then(({ heights, hmW, hmH, size, heightScale, heightBias }) => {
      heightSampler = (x, z) => heightAt(heights, hmW, hmH, x, z, size, heightScale, heightBias);
    });

    setupPointerLock();
    setupKeys();

    function updateMovement(delta) {
      direction.set(
        (keyState.right ? 1 : 0) - (keyState.left ? 1 : 0),
        0,
        (keyState.forward ? 1 : 0) - (keyState.backward ? 1 : 0) // positive means forward
      ).normalize();

      if (direction.lengthSq() > 0) {
        const speed = params.moveSpeed * delta;
        forward.copy(fpControls.getDirection(tmpDir)).setY(0).normalize();
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
        const pos = fpControls.getObject().position;
        pos.addScaledVector(forward, direction.z * speed);
        pos.addScaledVector(right, direction.x * speed);
      }
      const pos = fpControls.getObject().position;

      // Gravity and ground stick
      velocity.y -= params.gravity * delta;

      if (heightSampler) {
        const ground = heightSampler(pos.x, pos.z);
        const minY = ground + 6.5; // eye height
        if (pos.y + velocity.y * delta <= minY) {
          pos.y = minY;
          velocity.y = 0;
          isOnGround = true;
        } else {
          pos.y += velocity.y * delta;
          isOnGround = false;
        }
      }
    }

    function animate() {
      const delta = clock.getDelta();
      updateMovement(delta);
      if (orbit.enabled) {
        orbit.update();
      }
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();
  </script>
  <div
    style="position: fixed; bottom: 10px; right: 10px; color: rgba(255,255,255,0.3); font-size: 11px; font-family: sans-serif; pointer-events: none;">
    Examples created with the aid of AI: Antigravity + Models and VSCode CODEX extension.
  </div>
</body>

</html>